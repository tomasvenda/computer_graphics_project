<!DOCTYPE html>
<html>
<head>
    <title>3D Physics Maze Game</title>
    
    <script type="text/javascript" src="common/MV.js"></script>
    <script type="text/javascript" src="common/ammo.js"></script>
    <script type="text/javascript" src="common/quaternion.js"></script>
    <script type="text/javascript" src="ball.js"></script>
    <link rel="stylesheet" href="style.css">
    <script id="texture-wgsl" type="x-shader/x-wgsl" src="external_image.wgsl"></script>
    <script id="wgsl" type="x-shader">
    struct Uniforms {
        proj: mat4x4f,
        view: mat4x4f,
        model: mat4x4f,
        normal: mat4x4f,
        lightViewProj: mat4x4f,
        params: vec4f
    };
    @group(0) @binding(0) var<uniform> uniforms : Uniforms;
    @group(0) @binding(1) var shadowMap: texture_depth_2d;
    @group(0) @binding(2) var shadowSampler: sampler_comparison;
    @group(0) @binding(3) var grassTexture: texture_2d<f32>;
    @group(0) @binding(4) var grassSampler: sampler;
    @group(0) @binding(5) var woodTexture: texture_2d<f32>;
    @group(0) @binding(6) var woodSampler: sampler;
    @group(0) @binding(7) var ballTexture: texture_cube<f32>;
    @group(0) @binding(8) var ballSampler: sampler;

    struct VSOut {
        @builtin(position) position: vec4f,
        @location(0) vertexColor: vec3f,
        @location(1) shadowPos: vec3f,
        @location(2) uv: vec2f,
        @location(3) diffuseFactor: f32,
        @location(4) localPos: vec3f,
    };

    @vertex
    fn main_vs(@location(0) inPos: vec4f, @location(1) inNormal: vec4f) -> VSOut
    {
        const w_i = normalize(vec3(-1.0, 1.75, 1.0));
        let n = normalize((uniforms.normal*inNormal).xyz);
        let k_d = inPos.xyz*0.3 + 0.5;
        var vsOut: VSOut;
        vsOut.position = uniforms.proj*uniforms.view*uniforms.model*inPos;
        
        let diffuse = max(dot(n, w_i), 0.0);
        vsOut.diffuseFactor = diffuse;
        vsOut.vertexColor = k_d;
        vsOut.localPos = inPos.xyz;

        // Shadow calculation
        let posFromLight = uniforms.lightViewProj * uniforms.model * inPos;
        // Convert to texture coordinates
        vsOut.shadowPos = vec3f(
            posFromLight.xy * vec2f(0.5, -0.5) + vec2f(0.5, 0.5),
            posFromLight.z
        );

        // Planar Mapping for UVs based on object space position
        // Scale by s2 to make the texture repeat more frequently
        if (uniforms.params.x > 2.5) {
            // Cubemap uses localPos, so UV is not strictly needed, but we can set it to 0
            vsOut.uv = vec2f(0.0, 0.0);
        } else {
            // Planar Mapping for Floor/Walls
            vsOut.uv = inPos.xz * 2; 
        }

        return vsOut;
    }

    @fragment
    fn main_fs(@location(0) inVertexColor: vec3f, @location(1) shadowPos: vec3f, @location(2) uv: vec2f, @location(3) inDiffuseFactor: f32, @location(4) localPos: vec3f) -> @location(0) vec4f
    {
        var shadow = 0.0;
        // PCF (Percentage-Closer Filtering)
        let size = textureDimensions(shadowMap);
        let texelSize = vec2f(1.0 / f32(size.x), 1.0 / f32(size.y));
        
        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * texelSize;
                shadow += textureSampleCompare(
                    shadowMap, 
                    shadowSampler, 
                    shadowPos.xy + offset, 
                    shadowPos.z - 0.005 // bias
                );
            }
        }
        shadow /= 9.0;

        // Handle outside of shadow map
        if (shadowPos.x < 0.0 || shadowPos.x > 1.0 || shadowPos.y < 0.0 || shadowPos.y > 1.0) {
            shadow = 1.0;
        }

        var albedo = inVertexColor;
        if (uniforms.params.x > 0.5 && uniforms.params.x < 1.5) {
            albedo = textureSample(grassTexture, grassSampler, uv).rgb;
        } else if (uniforms.params.x > 1.5 && uniforms.params.x < 2.5) {
            albedo = textureSample(woodTexture, woodSampler, uv).rgb;
        } else if (uniforms.params.x > 2.5) {
            let direction = normalize(localPos);
            albedo = textureSample(ballTexture, ballSampler, direction).rgb;
        }

        let ambient = 0.5;
        let finalColor = albedo * (ambient + (1.0 - ambient) * inDiffuseFactor * shadow);

        return vec4f(finalColor, 1.0);
    }

    @vertex
    fn shadow_vs(@location(0) inPos: vec4f) -> @builtin(position) vec4f {
        return uniforms.lightViewProj * uniforms.model * inPos;
    }
    </script>
</head>
<body>
    <h1>The Maze Game</h1>
    
    <div id="game-container">
        <canvas id="webgpu-canvas" width="1200" height="675">
            Please use a browser that supports the HTML5 canvas element.
        </canvas>
        
        <div id="victory-message">
            <h2>VICTORY!</h2>
            <p>You reached the finish line!</p>
        </div>
    </div>

    <div id="instructions">
        <div class="key-group">
            <span class="label">TABLE CONTROL</span>
            <img src="arrowkeys.svg" class="key-icon" alt="Arrow Keys" />
        </div>
    </div>
</body>
</html>