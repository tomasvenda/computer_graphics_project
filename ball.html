<!DOCTYPE html>
<html>
<head>
    <title>3D Physics Maze Game</title>
    
    <script type="text/javascript" src="common/MV.js"></script>
    <script type="text/javascript" src="common/ammo.js"></script>
    <script type="text/javascript" src="common/quaternion.js"></script>
    <script type="text/javascript" src="ball.js"></script>
    <link rel="stylesheet" href="style.css">
    <script id="texture-wgsl" type="x-shader/x-wgsl" src="external_image.wgsl"></script>
    <script id="wgsl" type="x-shader">
    struct Uniforms {
        proj: mat4x4f,
        view: mat4x4f,
        model: mat4x4f,
        normal: mat4x4f,
        lightViewProj: mat4x4f,
        params: vec4f
    };
    @group(0) @binding(0) var<uniform> uniforms : Uniforms;
    @group(0) @binding(1) var shadowMap: texture_depth_2d;
    @group(0) @binding(2) var shadowSampler: sampler_comparison;
    @group(0) @binding(3) var grassTexture: texture_2d<f32>;
    @group(0) @binding(4) var grassSampler: sampler;
    @group(0) @binding(5) var woodTexture: texture_2d<f32>;
    @group(0) @binding(6) var woodSampler: sampler;
    @group(0) @binding(7) var ballTexture: texture_cube<f32>;
    @group(0) @binding(8) var ballSampler: sampler;

    struct VSOut {
        @builtin(position) position: vec4f,
        @location(0) vertexColor: vec3f,
        @location(1) shadowPos: vec3f,
        @location(2) uv: vec2f,
        @location(3) diffuseFactor: f32,
        @location(4) localPos: vec3f,
    };

    @vertex
    fn main_vs(@location(0) inPos: vec4f, @location(1) inNormal: vec4f) -> VSOut
    {
        const w_i = normalize(vec3(-1.0, 1.75, 1.0));
        let n = normalize((uniforms.normal*inNormal).xyz);
        let k_d = inPos.xyz*0.3 + 0.5;
        var vsOut: VSOut;
        vsOut.position = uniforms.proj*uniforms.view*uniforms.model*inPos;
        
        let diffuse = max(dot(n, w_i), 0.0);
        vsOut.diffuseFactor = diffuse;
        vsOut.vertexColor = k_d;
        vsOut.localPos = inPos.xyz;

        // Shadow calculation
        let posFromLight = uniforms.lightViewProj * uniforms.model * inPos;
        // Convert to texture coordinates
        vsOut.shadowPos = vec3f(
            posFromLight.xy * vec2f(0.5, -0.5) + vec2f(0.5, 0.5),
            posFromLight.z
        );

        // Planar Mapping for UVs based on object space position
        // Scale by s2 to make the texture repeat more frequently
        if (uniforms.params.x > 2.5) {
            // Cubemap uses localPos, so UV is not strictly needed, but we can set it to 0
            vsOut.uv = vec2f(0.0, 0.0);
        } else {
            // Planar Mapping for Floor/Walls
            vsOut.uv = inPos.xz * 4; 
        }

        return vsOut;
    }

    @fragment
    fn main_fs(@location(0) inVertexColor: vec3f, @location(1) shadowPos: vec3f, @location(2) uv: vec2f, @location(3) inDiffuseFactor: f32, @location(4) localPos: vec3f) -> @location(0) vec4f
    {
        var shadow = 0.0;
        // PCF (Percentage-Closer Filtering)
        let size = textureDimensions(shadowMap);
        let texelSize = vec2f(1.0 / f32(size.x), 1.0 / f32(size.y));
        
        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * texelSize;
                shadow += textureSampleCompare(
                    shadowMap, 
                    shadowSampler, 
                    shadowPos.xy + offset, 
                    shadowPos.z - 0.005 // bias
                );
            }
        }
        shadow /= 9.0;

        // Handle outside of shadow map
        if (shadowPos.x < 0.0 || shadowPos.x > 1.0 || shadowPos.y < 0.0 || shadowPos.y > 1.0) {
            shadow = 1.0;
        }

        var albedo = inVertexColor;
        if (uniforms.params.x > 0.5 && uniforms.params.x < 1.5) {
            albedo = textureSample(grassTexture, grassSampler, uv).rgb;
        } else if (uniforms.params.x > 1.5 && uniforms.params.x < 2.5) {
            albedo = textureSample(woodTexture, woodSampler, uv).rgb;
        } else if (uniforms.params.x > 2.5) {
            let direction = normalize(localPos);
            albedo = textureSample(ballTexture, ballSampler, direction).rgb;
        }

        let ambient = 0.5;
        let finalColor = albedo * (ambient + (1.0 - ambient) * inDiffuseFactor * shadow);

        return vec4f(finalColor, 1.0);
    }

    @vertex
    fn shadow_vs(@location(0) inPos: vec4f) -> @builtin(position) vec4f {
        return uniforms.lightViewProj * uniforms.model * inPos;
    }
    </script>
</head>
<body>
    <div id="game-container">
        <h1>WebGPU with a Physics Engine Maze Game</h1>
        <p>By Tomas and Andrei, December 2025</p>
        <canvas id="webgpu-canvas">
            Please use a browser that supports the HTML5 canvas element.
        </canvas>
        
        <div id="game-menu">
            <div class="menu-section">
                <span class="menu-label">LEVEL</span>
                <div class="level-selector">
                    <button class="level-btn current" id="lvl-btn-0" onclick="loadLevel(0)">1</button>
                    <button class="level-btn locked" id="lvl-btn-1" onclick="loadLevel(1)">2</button>
                    <button class="level-btn locked" id="lvl-btn-2" onclick="loadLevel(2)">3</button>
                    <button class="level-btn locked" id="lvl-btn-3" onclick="loadLevel(3)">4</button>
                    <button class="level-btn locked" id="lvl-btn-4" onclick="loadLevel(4)">5</button>
                </div>
            </div>
            <div class="menu-section">
                <span class="menu-label">BALL SKIN</span>
                <div class="skin-selector">
                    <button class="skin-btn active" id="skin-tennis" onclick="changeBallTexture('tennis')">Tennis</button>
                    <button class="skin-btn" id="skin-jabulani" onclick="changeBallTexture('jabulani')">Jabulani</button>
                    <button class="skin-btn" id="skin-telstar" onclick="changeBallTexture('telstar')">Telstar</button>
                    <button class="skin-btn" id="skin-basketball" onclick="changeBallTexture('basketball')">Basketball</button>
                </div>
            </div>
        </div>

        <div id="victory-message">
            <h2>VICTORY!</h2>
            <p>You reached the finish line!</p>
            <button id="next-level-btn" onclick="nextLevel()">Next Level</button>
        </div>

        <div id="instructions">
            <div class="key-group">
                <span class="label">TABLE CONTROLS: </span>
                <img src="arrowkeys.svg" class="key-icon" alt="Arrow Keys" />
            </div>
        </div>
    </div>
    <script>
    (function() {
        const canvas = document.getElementById('webgpu-canvas');
        if (!canvas) return;

        function resizeCanvas() {
            const dpr = Math.max(window.devicePixelRatio || 1, 1);
            const rect = canvas.getBoundingClientRect();
            const width = Math.max(1, Math.round(rect.width * dpr));
            const height = Math.max(1, Math.round(rect.height * dpr));
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                // notify any renderer that listens for resizes
                try { window.dispatchEvent(new Event('canvas-resize')); } catch(e){}
            }
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            resizeCanvas();
        } else {
            window.addEventListener('DOMContentLoaded', resizeCanvas);
        }
    })();
    </script>
</body>
</html>